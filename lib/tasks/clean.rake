desc 'Set current false for older data_points when there are multiple current data_points for a given date'
task :clean_current => :environment do
  Series.all.each { |series|
    DataPoint.select('max(created_at) as created_at, date').where(series_id: series.id, current: 1).group(:date).each { |dp|
      DataPoint.where(series_id: series.id, current: 1, date: dp.date).where('created_at < ?', dp.created_at).each do |inner_dp|
        inner_dp.current = false
        inner_dp.save
      end
    }
  }
end

desc 'Keep only the two most recent data_points for each series, data_source, and date'
task :trim_data_point_history => :environment do
  ActiveRecord::Base.connection.execute(%Q|DELETE FROM data_points
WHERE (series_id, data_source_id, date, created_at)
  IN (SELECT series_id, data_source_id, date, created_at
FROM
  (SELECT series_id, data_source_id, date, created_at,
     (CASE date
      WHEN @curDate
        THEN @curRow := @curRow + 1
      ELSE @curRow := 1 AND @curDate := date END) AS rank
   FROM data_points, (SELECT @curRow := 0, @curDate := '') r
   ORDER BY series_id, data_source_id, date, created_at DESC)
    AS older WHERE rank > 2)|)
end

desc 'Set data_list series associations based on the serialized list of series in each data_list'
task :add_data_list_series_associations => :environment do
  DataList.find_each(batch_size: 10) do |dl|
    # series_ids method is generated by has_and_belongs_to_many in data_list.rb
    dl.series_ids = dl.get_sibling_series_ids
  end
end

desc 'Create measurements from series table and destroy the old ones'
task :reset_measurements => :environment do
  # reset measurement tables
  ActiveRecord::Base.connection.execute('UPDATE series SET measurement_id = NULL;')
  ActiveRecord::Base.connection.execute('DELETE FROM measurements;')
  ActiveRecord::Base.connection.execute('ALTER TABLE measurements AUTO_INCREMENT = 1;')
  ActiveRecord::Base.connection.execute('DELETE FROM data_list_measurements;')
  ActiveRecord::Base.connection.execute('ALTER TABLE data_list_measurements AUTO_INCREMENT = 1;')
  ActiveRecord::Base.connection.execute(%Q|INSERT INTO
measurements (prefix, data_portal_name, units_label, units_label_short, percent, `real`, created_at, updated_at)
(SELECT
  TRIM(TRAILING '&NS' FROM TRIM(TRAILING 'NS' FROM UPPER(LEFT(series.name, LOCATE('@', series.name) - 1)))) AS prefix,
  MAX(dataPortalName) AS data_portal_name,
  MAX(unitsLabel) AS units_label, MAX(unitsLabelShort) AS units_label_short, MAX(percent) AS percent,
  MAX(series.real) AS `real`, NOW(), NOW()
FROM series GROUP BY
  TRIM(TRAILING '&NS' FROM TRIM(TRAILING 'NS' FROM UPPER(LEFT(series.name, LOCATE('@', series.name) - 1))))
);|)

  # set data_list - measurement associations
  DataList.find_each(batch_size: 10) do |dl|
    list = dl.list.split(/\r\n/).map{|s| s[/[^@]*/].upcase.chomp('NS').gsub(/NS&$/, '&')}
    list.each_index do |list_order|
      m = Measurement.find_by(prefix: list[list_order])
      if m.nil?
        next
      end
      dl.measurements<< m unless dl.measurements.include?(m)
      DataListMeasurement.find_by(data_list_id: dl.id, measurement_id: m.id).update(list_order: list_order)
    end
  end

  # set measurement - series associations
  Series.find_each(batch_size: 50) do |s|
    s.measurement = Measurement.find_by prefix: s.name[/[^@]*/].upcase.chomp('NS').gsub(/NS&$/, '&')
    s.save
  end
end

desc 'Use series names to reset seasonally_adjusted'
task :reset_seasonally_adjusted => :environment do
  ActiveRecord::Base.connection.execute('UPDATE series SET seasonally_adjusted = NULL;')
  Measurement.find_each(batch_size: 10) do |m|
    series_names = m.series.pluck(:name)
    if !series_names.index{|name| name[/NS&?@/]}.nil? && !series_names.all?{|name| name[/NS&?@/]}
      m.series.each do |s|
        s.update seasonally_adjusted: s.name[/NS&?@/].nil?
      end
    end
  end
end

desc 'Load exports from data_lists'
task :build_exports_from_data_lists => :environment do
  DataList.find_each(batch_size: 10) do |dl|
    export = Export.create(name: dl.name, created_by: dl.created_by, updated_by: dl.updated_by, owned_by: dl.owned_by)
    series_ids = dl.series_names.map do |sn|
      begin
        sn.ts.id unless sn.ts.nil?
      rescue SeriesNameException
        nil
      end
    end
    series_ids.compact!
    series_ids.each_index do |i|
      ExportSeries.create(export_id: export.id, series_id: series_ids[i], list_order: i) unless ExportSeries.exists?(export_id: export.id, series_id: series_ids[i])
    end
  end
end