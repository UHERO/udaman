desc 'Set current false for older data_points when there are multiple current data_points for a given date'
task :clean_current => :environment do
  Series.all.each { |series|
    DataPoint.select('max(created_at) as created_at, date').where(series_id: series.id, current: 1).group(:date).each { |dp|
      DataPoint.where(series_id: series.id, current: 1, date: dp.date).where('created_at < ?', dp.created_at).each do |inner_dp|
        inner_dp.current = false
        inner_dp.save
      end
    }
  }
end

desc 'Keep only the two most recent data_points for each series, data_source, and date'
task :trim_data_point_history => :environment do
  ActiveRecord::Base.connection.execute(%Q|DELETE FROM data_points
WHERE (series_id, data_source_id, date, created_at)
  IN (SELECT series_id, data_source_id, date, created_at
FROM
  (SELECT series_id, data_source_id, date, created_at,
     (CASE date
      WHEN @curDate
        THEN @curRow := @curRow + 1
      ELSE @curRow := 1 AND @curDate := date END) AS rank
   FROM data_points, (SELECT @curRow := 0, @curDate := '') r
   ORDER BY series_id, data_source_id, date, created_at DESC)
    AS older WHERE rank > 2)|)
end

desc 'Set data_list series associations based on the serialized list of series in each data_list'
task :add_data_list_series_associations => :environment do
  DataList.find_each(batch_size: 10) do |dl|
    # series_ids method is generated by has_and_belongs_to_many in data_list.rb
    dl.series_ids = dl.get_sibling_series_ids
  end
end

desc 'Create measurements from series table and destroy the old ones'
task :reset_measurements => :environment do
  ActiveRecord::Base.connection.execute('DELETE FROM measurements;')
  ActiveRecord::Base.connection.execute(%Q|INSERT INTO
measurements (prefix, data_portal_name, units_label, units_label_short, percent, `real`, created_at, updated_at)
(SELECT LEFT(series.name, LOCATE('@', series.name) - 1) AS prefix, MAX(dataPortalName) AS data_portal_name,
  MAX(unitsLabel) AS units_label, MAX(unitsLabelShort) AS units_label_short, MAX(percent) AS percent,
  MAX(series.real) AS `real`, NOW(), NOW()
FROM series GROUP BY LEFT(series.name, locate('@', series.name) - 1));|)
  Series.find_each(batch_size: 50) do |s|
    s.measurement = Measurement.find_by prefix: s.name[/[^@]*/]
    s.save
  end
end

desc 'Use data_list list to build data_lists_measurements'
task :build_data_list_measurements => :environment do
  DataList.find_each(batch_size: 50) do |dl|
    list = dl.list.split("\r\n").map{|s| s[/[^@]*/]}
    list.each_index do |list_order|
      measurement = Measurement.find_by(prefix: list[list_order])
      if measurement.nil?
        puts list[list_order]
        next
      end
      dl.measurements<< measurement unless dl.measurements.include?(measurement)
      DataListMeasurement.find_by(data_list_id: dl.id, measurement_id: measurement.id).update(list_order: list_order)
    end
  end
end