<p id="notice"><%= notice %></p>

<%= link_to 'Edit', edit_forecast_snapshot_path(@forecast_snapshot) %> |
<%= link_to 'Back', forecast_snapshots_path %>

<h2><%= @forecast_snapshot.name+' ('+@forecast_snapshot.version+')' %></h2>
<div id="charts_container"></div>

<script>
  // TSD labels used for chart series' names
  var history_label = '<%= @forecast_snapshot.history_tsd_label %>',
      old_forecast_label = '<%= @forecast_snapshot.old_forecast_tsd_label %>',
      new_forecast_label = '<%= @forecast_snapshot.new_forecast_tsd_label %>';

  // Create array of series objects
  var all_data = [];

  <% start_date = '2020-01-01' %>
  <% @forecast_snapshot.history_tsd.get_all_series.each do |series| %>
    <% series_start = @forecast_snapshot.history_tsd.parse_date(series[:start], series[:frequency], :start, series[:daily_switches]) %>
    <% start_date = series_start if start_date > series_start %>
    <% mnemonic = series[:name] + '.' + series[:frequency] %>
    <% @forecast_snapshot.unrestrict_series(mnemonic) %>
    all_data.push({
      series: '<%= series[:name] %>',
      id: '<%= @forecast_snapshot.retrieve_series_id(mnemonic) %>',
      title: '<%= @forecast_snapshot.retrieve_name(mnemonic) %>',
      frequency: '<%= series[:frequency] %>',
      units: '<%= @forecast_snapshot.retrieve_units(series[:name][/[^@]*/]) %>',
      history_start: '<%= series_start %>',
      history: [<% series[:data].each do |e| %> <% if e == ' 1.000000E+0015'  %> <%= 'null' %>, <% elsif e == '               ' %><%= 'null' %>, <% else %><%= e.to_f %>, <% end %><% end %>],
    });
  <% end %>

  <% @forecast_snapshot.old_forecast_tsd.get_all_series.each do |series| %>
    <% mnemonic = series[:name] + '.' + series[:frequency] %>
    <% series_start = @forecast_snapshot.old_forecast_tsd.parse_date(series[:start], series[:frequency], :start, series[:daily_switches]) %>
    <% start_date = series_start if start_date > series_start %>
    <% @forecast_snapshot.unrestrict_series(mnemonic) %>
    all_data.push({
      series: '<%= series[:name] %>',
      id: '<%= @forecast_snapshot.retrieve_series_id(mnemonic) %>',
      title: '<%= @forecast_snapshot.retrieve_name(mnemonic) %>',
      frequency: '<%= series[:frequency] %>',
      units: '<%= @forecast_snapshot.retrieve_units(series[:name][/[^@]*/]) %>',
      old_forecast_start: '<%= series_start %>',
      old_forecast: [<% series[:data].each do |e| %> <% if e == ' 1.000000E+0015'  %> <%= 'null' %>, <% elsif e == '               ' %><%= 'null' %>, <% else %><%= e.to_f %>, <% end %><% end %>],
    });
  <% end %>

  <% @forecast_snapshot.new_forecast_tsd.get_all_series.each do |series| %>
    <% mnemonic = series[:name] + '.' + series[:frequency] %>
    <% series_start = @forecast_snapshot.new_forecast_tsd.parse_date(series[:start], series[:frequency], :start, series[:daily_switches]) %>
    <% start_date = series_start if start_date > series_start %>
    <% @forecast_snapshot.unrestrict_series(mnemonic) %>
    all_data.push({
      series: '<%= series[:name] %>',
      id: '<%= @forecast_snapshot.retrieve_series_id(mnemonic) %>',
      title: '<%= @forecast_snapshot.retrieve_name(mnemonic) %>',
      frequency: '<%= series[:frequency] %>',
      units: '<%= @forecast_snapshot.retrieve_units(series[:name][/[^@]*/]) %>',
      new_forecast_start: '<%= series_start %>',
      new_forecast: [<% series[:data].each do |e| %> <% if e == ' 1.000000E+0015'  %> <%= 'null' %>, <% elsif e == '               ' %><%= 'null' %>, <% else %><%= e.to_f %>, <% end %><% end %>],
    });
  <% end %>

  // Remove nulls, added by empty strings at end of TSDs, from end of array only.
  for (var i = 0; i < all_data.length; i++) {
    if (all_data[i].history) {
      var historyData = all_data[i].history.reduceRight(function(result, a) {
        return result.length === 0 && a === null ? result : [a].concat(result);
      }, []);
      all_data[i].filter_history = historyData;
    }
    if (all_data[i].old_forecast) {
      var oldForecastData = all_data[i].old_forecast.reduceRight(function(result, a) {
        return result.length === 0 && a === null ? result : [a].concat(result);
      }, []);
      all_data[i].filter_old_forecast = oldForecastData;
    }
    if (all_data[i].new_forecast) {
      var newForecastData = all_data[i].new_forecast.reduceRight(function(result, a) {
        return result.length === 0 && a === null ? result : [a].concat(result);
      }, []);
      all_data[i].filter_new_forecast = newForecastData;
    }
  }

  // Consolidate objects belonging to the same series
  var chart_data = [];
  var start_date = "<%= start_date %>";
  all_data.forEach(function(value) {
    var exist = chart_data.filter(function(e, i) {
      return e.series === value.series;
    });
    if (exist.length) {
      var existIndex = chart_data.indexOf(exist[0]);
      if (!chart_data[existIndex].hasOwnProperty('filter_history') && value.filter_history) {
        chart_data[existIndex].filter_history = value.filter_history;
      }
      if (!chart_data[existIndex].hasOwnProperty('history_start') && value.history_start) {
        chart_data[existIndex].history_start = value.history_start;
      }
      if (!chart_data[existIndex].hasOwnProperty('filter_old_forecast') && value.filter_old_forecast) {
        chart_data[existIndex].filter_old_forecast = value.filter_old_forecast;
      }
      if (!chart_data[existIndex].hasOwnProperty('old_forecast_start') && value.old_forecast_start) {
        chart_data[existIndex].old_forecast_start = value.old_forecast_start;
      }
      if (!chart_data[existIndex].hasOwnProperty('filter_new_forecast') && value.filter_new_forecast) {
        chart_data[existIndex].filter_new_forecast = value.filter_new_forecast;
      }
      if (!chart_data[existIndex].hasOwnProperty('new_forecast_start') && value.new_forecast_start) {
        chart_data[existIndex].new_forecast_start = value.new_forecast_start;
      }
    } else {
      chart_data.push(value);
    }
  });

  // Calculate YOY percentage change in new and old forecast
  for (i = 0; i < chart_data.length; i++) {
    chart_data[i].start_date_chart = start_date;
    if (chart_data[i].frequency === 'A') {
      leftPadAnnual(chart_data[i]);
      chart_data[i].new_forecast_yoy = [];
      chart_data[i].old_forecast_yoy = [];
      chart_data[i].new_forecast_yoy = yoy(chart_data[i].filter_new_forecast, 1);
      chart_data[i].old_forecast_yoy = yoy(chart_data[i].filter_old_forecast, 1);
    } else if (chart_data[i].frequency === 'Q') {
      leftPadQuarterly(chart_data[i]);
      chart_data[i].new_forecast_yoy = [];
      chart_data[i].old_forecast_yoy = [];
      chart_data[i].new_forecast_yoy = yoy(chart_data[i].filter_new_forecast, 4);
      chart_data[i].old_forecast_yoy = yoy(chart_data[i].filter_old_forecast, 4);
    }
  }

  function leftPadAnnual(series) {
      if (series.history_start > series.start_date_chart) {
         histPad = parseInt(series.history_start.split('-')[0]) - parseInt(series.start_date_chart.split('-')[0]);
          series.filter_history = (new Array(histPad)).fill(null).concat(series.filter_history);
      }
      if (series.old_forecast_start > series.start_date_chart) {
          histPad = parseInt(series.old_forecast_start.split('-')[0]) - parseInt(series.start_date_chart.split('-')[0]);
          series.filter_old_forecast = (new Array(histPad)).fill(null).concat(series.filter_old_forecast);
      }
      if (series.new_forecast_start > series.start_date_chart) {
          histPad = parseInt(series.new_forecast_start.split('-')[0]) - parseInt(series.start_date_chart.split('-')[0]);
          series.filter_new_forecast = (new Array(histPad)).fill(null).concat(series.filter_new_forecast);
      }
  }

  function leftPadQuarterly(series) {
      startDate = series.start_date_chart.split('-').map(function(v) { return parseInt(v); });
      if (series.history_start > series.start_date_chart) {
          histDate = series.history_start.split('-').map(function(v) { return parseInt(v); });
          histPad = (histDate[0] - startDate[0]) * 4 + (histDate[1] - startDate[1]) / 3;
          series.filter_history = (new Array(histPad)).fill(null).concat(series.filter_history);
      }
      if (series.old_forecast_start > series.start_date_chart) {
          oldFcDate = series.old_forecast_start.split('-').map(function(v) { return parseInt(v); });
          oldFcPad = (oldFcDate[0] - startDate[0]) * 4 + (oldFcDate[1] - startDate[1]) / 3;
          series.filter_old_forecast = (new Array(oldFcPad)).fill(null).concat(series.filter_old_forecast);
      }
      if (series.new_forecast_start > series.start_date_chart) {
          newFcDate = series.new_forecast_start.split('-').map(function(v) { return parseInt(v); });
          newFcPad = (newFcDate[0] - startDate[0]) * 4 + (newFcDate[1] - startDate[1]) / 3;
          series.filter_new_forecast = (new Array(newFcPad)).fill(null).concat(series.filter_new_forecast);
      }
  }

  function minDate(history_date, old_date, new_date) {
    var min = history_date;
    if (old_date < min) {
      min = old_date;
    }
    if (new_date < min) {
      min = new_date;
    }
    return min;
  }

  // Function to calculate YOY % change (annual)
  // Returns a yoy series from the given observations
  function yoy(observations, observationsPerYear) {
    return observations.map(function (value, index, observations) {
        if (index < observationsPerYear) {
            return null;
        }
        var previousValue = observations[index - observationsPerYear];
        if (isNaN(parseFloat(value)) || isNaN(parseFloat(previousValue))) {
            return null;
        }
        return (value - previousValue)/previousValue * 100;
    });
  }

  $(document).ready(function() {
    Highcharts.setOptions({
      lang: {
        thousandsSep: ','
      }
    });

    for(i = 0; i < chart_data.length; i++) {
      // Create a div container for each chart
      $('div#charts_container').append('<div id="' + i + '"/>');

      // Set intervals and frequency. User to format xAxis labels and tooltips
      var interval, intervalUnit, dateLabel, frequency;
      var plotLine = [];

      if (chart_data[i].frequency === 'A') {
        interval = 1;
        intervalUnit = 'year';
        dateLabel = {year: '%Y'};
        frequency = 'A'
      } else if (chart_data[i].frequency === 'Q') {
        interval = 3;
        intervalUnit = 'month';
        dateLabel = {month: '%b %Y'};
        frequency = 'Q'
      }

      // Create a highchart for each series
      $('#' + i).highcharts({
        chart: {
          alignTicks: false
        },
        title: {
          text: i + '. ' + '<a href="http://data.uhero.hawaii.edu/#/series?id=' + chart_data[i].id + '" target="_blank">' + chart_data[i].title + ' (' + chart_data[i].series + ')' + '</a>',
          align: 'left',
          useHTML: true,
          style: {
            textTransform: 'capitalize'
          }
        },
        credits: {
          enabled: false
        },
        plotOptions: {
          line: {
            marker: {
              enabled: false
            }
          },
          series: {
            pointStart: Date.parse(chart_data[i].start_date_chart),
            pointInterval: interval,
            pointIntervalUnit: intervalUnit,
            events: {
              legendItemClick: function() {
                return false; // Prevent series from being toggled on/off
              }
            }
          }
        },
        xAxis: {
          type: 'datetime',
          dateTimeLabelFormats: dateLabel
        },
        yAxis: [{
          title: {
            text: chart_data[i].units
          },
          labels: {
            format: '{value:,.2f}'
          },
          minPadding: 0,
          maxPadding: 0
        }, {
          title: {
            text: '% Change in Forecast'
          },
          labels: {
            format: '{value:,.2f}'
          },
          gridLineWidth: 0,
          opposite: true,
          minPadding: 0,
          maxPadding: 0
        }],
        tooltip: {
          shared: true,
          hideDelay: 50,
          formatter: function () {
            var s = '<b>';
            if (frequency === 'Q' && Highcharts.dateFormat('%b', this.x) === 'Jan') {
              s = s + 'Q1'
            }
            if (frequency === 'Q' && Highcharts.dateFormat('%b', this.x) === 'Apr') {
              s = s + 'Q2'
            }
            if (frequency === 'Q' && Highcharts.dateFormat('%b', this.x) === 'Jul') {
              s = s + 'Q3'
            }
            if (frequency === 'Q' && Highcharts.dateFormat('%b', this.x) === 'Oct') {
              s = s + 'Q4'
            }
            s = s + ' ' + Highcharts.dateFormat('%Y', this.x) + '</b>';
            $.each(this.points, function (i, point) {
              s += '<br><span style="color:' + point.series.color + '">\u25CF</span>' + point.series.name + ': ' + Highcharts.numberFormat(point.y);
            });
            return s;
          }
        },
        series: [{
          name: history_label,
          type: 'line',
          dashStyle: 'dash',
          data: chart_data[i].filter_history,
          yAxis: 0,
          zIndex: 4
        },{
          name: old_forecast_label,
          type: 'line',
          dashStyle: 'dash',
          color: '#F6A01B',
          data: chart_data[i].filter_old_forecast,
          yAxis: 0,
          zIndex: 3
        }, {
          name: new_forecast_label,
          type: 'line',
          color: '#1D667F',
          data: chart_data[i].filter_new_forecast,
          yAxis: 0,
          zIndex: 2
        }, {
          name: 'YOY % Change in ' + new_forecast_label,
          type: 'column',
          color: '#737373',
          borderColor: 'transparent',
          data: chart_data[i].new_forecast_yoy,
          yAxis: 1,
          zIndex: 1
        }, {
          name: 'YOY % Change in ' + old_forecast_label,
          showInLegend: false,
          type: 'column',
          color: 'transparent',
          borderColor: 'transparent',
          data: chart_data[i].old_forecast_yoy,
          yAxis: 1
        }]
      }, function(chart) {
        // Adding plot lines
        var xAxis = chart.xAxis[0],
            historyDates = xAxis.series[0].xData,
            oldForecastDates = xAxis.series[1].xData,
            newForecastDates = xAxis.series[2].xData,
            histDatesLength = historyDates.length,
            oldDatesLength = oldForecastDates.length,
            newDatesLength = newForecastDates.length,
            // Get last date from History series
            lastHistoryDate = historyDates[histDatesLength - 1];

        // Use date array of forecast with largest range
        var longerForecast = oldDatesLength < newDatesLength ? newForecastDates : oldForecastDates,
            histDateIndex = longerForecast.indexOf(lastHistoryDate),
            // Get array of dates from last history date to date of last observation
            plotLineRange = longerForecast.slice(histDateIndex);

        // Add a plot line at the last history point and every year after that is divisible by 5
        for (var i = 0; i < plotLineRange.length; i++) {
          if (frequency === 'A') {
            if (+Highcharts.dateFormat('%Y', plotLineRange[i]) % 5 === 0 || plotLineRange[i] === lastHistoryDate) {
              xAxis.addPlotLine({value: plotLineRange[i], color: '#ADADAD', width: 1, dashStyle: 'LongDash'});
            }
          } else if (frequency === 'Q') {
            if ((Highcharts.dateFormat('%b', plotLineRange[i]) === 'Jan' && +Highcharts.dateFormat('%Y', plotLineRange[i]) % 5 === 0) || plotLineRange[i] === lastHistoryDate) {
              xAxis.addPlotLine({value: plotLineRange[i], color: '#ADADAD', width: 1, dashStyle: 'LongDash'});
            };
          }
        }
      });
    }
  });
</script>
